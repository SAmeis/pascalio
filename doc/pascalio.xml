<?xml version="1.0" encoding="utf-8"?>
<fpdoc-descriptions>
  <package name="pascalio">
    <module name="bitmanip">
      <element name="TByteSize">
        <short>Index of Bit in byte</short>
      </element>
      <element name="TWordSize">
        <short>Index of Bit in word</short>
      </element>
      <element name="TDWordSize">
        <short>Index of Bit in double word</short>
      </element>
      <element name="TQWordSize">
        <short>Index of Bit in quad word</short>
      </element>
      <element name="BITSET">
        <short>Set bit</short>
      </element>
      <element name="BITSET.Result">
        <short>Changed value</short>
      </element>
      <element name="BITSET.aVal">
        <short>Input Value</short>
      </element>
      <element name="BITSET.Index">
        <short>Bit Index</short>
      </element>
      <element name="BITCLS">
        <short>Clear bit</short>
      </element>
      <element name="BITCLS.Result">
        <short>Changed value</short>
      </element>
      <element name="BITCLS.aVal">
        <short/>
      </element>
      <element name="BITCLS.Index">
        <short/>
      </element>
      <element name="BITVAL">
        <short>Bit Value</short>
      </element>
      <element name="BITVAL.Result">
        <short>Value of bit</short>
      </element>
      <element name="BITVAL.aVal">
        <short/>
      </element>
      <element name="BITVAL.Index">
        <short/>
      </element>
      <element name="BITTGL">
        <short>Toggle bit</short>
      </element>
      <element name="BITTGL.Result">
        <short>Changed value</short>
      </element>
      <element name="BITTGL.aVal">
        <short/>
      </element>
      <element name="BITTGL.Index">
        <short/>
      </element>
      <element name="CountBits">
        <short>Count bits set</short>
        <descr>
          <p>Returns the count of bits set in 
<var>v</var>.</p>
          <code>var
  value: Byte;
  c: PtrUInt;
begin
  value := 5;
  // bits set
  c := CountBits(value); // c is now 2
  // bits not set
  c := CountBits(not value); // c is now 6
end.
</code>
          <p>The used algorith is taken from <url href="http://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel">Bit Twiddling Hacks</url>
          </p>
        </descr>
      </element>
      <element name="CountBits.Result">
        <short/>
      </element>
      <element name="CountBits.v">
        <short>Input value</short>
      </element>
      <short>Bit manipulations</short>
      <descr>
        <p>This unit provides functions for manipulating bits in a functional manner.</p>
      </descr>
    </module>
  <module name="flqueue">
      <element name="tNodeQueue">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="tFLQueue">
        <short>Lock free queue of tObject (pointer)</short>
      </element>
      <element name="tFLQueue.fSize">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="tFLQueue.fMask">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="tFLQueue.tab">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="tFLQueue.tail">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="tFLQueue.head">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="tFLQueue.temp">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="tFLQueue.setobject">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="tFLQueue.setobject.lp">
        <short/>
      </element>
      <element name="tFLQueue.setobject.aobject">
        <short/>
      </element>
      <element name="tFLQueue.getLength">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="tFLQueue.getLength.Result">
        <short/>
      </element>
      <element name="tFLQueue.getObject">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="tFLQueue.getObject.Result">
        <short/>
      </element>
      <element name="tFLQueue.getObject.lp">
        <short/>
      </element>
      <element name="tFLQueue.create">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="tFLQueue.create.aPower">
        <short/>
      </element>
      <element name="tFLQueue.push">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="tFLQueue.push.tm">
        <short/>
      </element>
      <element name="tFLQueue.pop">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="tFLQueue.pop.Result">
        <short/>
      </element>
      <element name="tFLQueue.length">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <short>Lock free queue</short>
      <descr>
        <p>Has two implementation queue based on curcular array proposed by Dariusz Mazur use only single CAS.</p>
        <ul>
          <li>
            <link id="tFLQueue"/>: for queue of tObject (pointer)</li>
          <li>gFlQueue: generic queue of any record (not included in theses sources)</li>
        </ul>
        <p>
          <b>Caution:</b> if You set too small size of array and store data excess size of queue data will be lost</p>
      </descr>
    </module><module name="fpadc">
      <element name="TADConverter">
        <short>Abstract class for Analog/Digital Converters</short>
        <descr>This is an abstract class for Analgo/Digital Converters (ADC). Typically each ADC requires an individual implementation for data access, so create derived classes for each ADC. You must override all abstract methods to enable reading of single pin data. If the chip also supports differential or pseudo differential measurement, you should override 

<link id="TADConverter.DifferentialValue">DifferentialValue</link> and 

<link id="TADConverter.GetDifferentialValue">GetDifferentialValue</link>, also.</descr>
      </element>
      <element name="TADConverter.MaxValue">
        <short>Maximum returned value</short>
      </element>
      <element name="TADConverter.Value">
        <short>Get value for input channel</short>
      </element>
      <element name="TADConverter.Count">
        <short>Count of input channels</short>
      </element>
      <element name="TADConverter.DifferentialValue">
        <short>Get differential value from input</short>
        <descr>Some A/D-converters support differential or pseudo differential measurement. Check 

<link id="TADConverter.SupportsDifferentialValue">SupportsDifferentialValue</link> before usage. Please consult the datasheet of your device on information how connectors are used in differential measuring.</descr>
        <errors>Raises 

<link id="EDifferentialNotSupported"/> if used but is not supported.</errors>
        <seealso>
          <link id="TADConverter.SupportsDifferentialValue"/>
        </seealso>
      </element>
      <element name="TADConverter.SupportsDifferentialValue">
        <short>Indication of differantial measurement capability</short>
      </element>
      <element name="EDifferentialNotSupported">
        <short>Missing support for differential measurement</short>
        <seealso>
          <link id="TADConverter.DifferentialValue"/>
          <link id="TADConverter.SupportsDifferentialValue"/>
        </seealso>
      </element>
      <element name="EADCError">
        <short>Generic ADC exception</short>
      </element>
      <element name="TADConverter.GetSupportsDifferentialValue">
        <short>Indicator of support for differential measurement</short>
        <descr>Returns <var>False</var> by default. Override it and return <var>True</var> if <link id="TADConverter.GetDifferentialValue">GetDifferentialValue</link> implements something useful.</descr>
        <seealso>
          <link id="TADConverter.GetDifferentialValue"/>
        </seealso>
      </element>
      <element name="TADConverter.GetDifferentialValue">
        <short>Returns differential value</short>
        <descr>Override this function if your ADC supports differential measurement. Override <link id="TADConverter.GetSupportsDifferentialValue">GetSupportsDifferentialValue</link>, too.</descr>
        <errors>Raises <link id="EDifferentialNotSupported"/> if not implemented in child class.</errors>
        <seealso>
          <link id="TADConverter.GetSupportsDifferentialValue"/>
          <link id="EDifferentialNotSupported"/>
        </seealso>
      </element>
      <element name="TADConverter.GetMaxValue">
        <short>Returns maximum value provided by ADC</short>
        <descr>
          <p>Override this method and return the highst value, the controller may measure.</p>
          <p>Example: a 10 bit ADC may return 1024 different values. Therfore 1023 is the highest value and has to be returned by this method.</p>
        </descr>
      </element>
      <element name="TADConverter.GetCount">
        <short>Return count of input channels</short>
      </element>
      <element name="TADConverter.GetValue">
        <short>Retrives actual value</short>
        <descr>Override this method and implement somthing to get the acual values from the AD Converter.</descr>
      </element>
      <element name="TADConverter.GetDifferentialValue.Index">
        <short>Index of channel</short>
        <descr>It depends on the AD Converter how this number is interpreted. Read the datasheet.</descr>
      </element>
      <element name="TADConverter.GetValue.Index">
        <short>Index of input channel</short>
      </element>
      <element name="EDifferentialNotSupported.Create">
        <short>Create new instance with predefined message</short>
        <descr>Creates a new exception object <link id="EDifferentialNotSupported"/> with predefined text.</descr>
        <seealso>
          <link id="sDiffNotSupported"/>
        </seealso>
      </element>
      <element name="sDiffNotSupported">
        <short>Class doesn't support differential values.</short>
        <seealso>
          <link id="EDifferentialNotSupported.Create"/>
        </seealso>
      </element>
      <short>Analog/Digital Converters</short>
      <descr>This unit contains an abstract base class <link id="TADConverter"/> for Analog to Digital Converters (ADC).</descr>
    </module><module name="fpgpio">
      <element name="TGpioPin.PollChange">
        <short>Polls GPIO pin for change</short>
      </element>
      <element name="TGpioPin">
        <short>Abstract GPIO class</short>
      </element>
      <element name="TGpioPin.PollChange.delay">
        <short>Delay between polls in milliseconds</short>
        <descr>If <var>delay</var> is negative (-1 or less), the next poll will be done imediatly.
If <var>delay</var> is exactly 0, <code>sleep(0)</code> will be called. Thus the remaining time slice will be returned to the OS' scheduler and your application/thread will sleep until it gets a new time slice.
If <var>delay</var> is greater than 0, <code>sleep(delay)</code> will be called. Your application/thread will be paused for at least this amount of time (but maybe a little longer).</descr>
      </element>
      <element name="TGpioPin.PollChange.timeout">
        <short>Maximum time for polling in milliseconds</short>
        <descr>Method will return, when <var>timeout</var> milliseconds have passed without changing <link id="TGpioPin.Value"/>.</descr>
      </element>
      <element name="TGpioPin.Value">
        <short>Value of GPIO pin</short>
      </element>
      <element name="TGpioPin.PollChange.changed">
        <short>New value</short>
      </element>
      <element name="TGpioPin.PollChange.value">
        <short>New Value</short>
        <descr>Contains the new value if not timed out.</descr>
      </element>
      <element name="TGpioPin.PollChange.Result">
        <short>Indicates timeout, change or cancel</short>
        <descr>
          <var>True</var> indicates a change in 
          
          
          
          <link id="TGpioPin.Value"/>; the value is stored in           
          
          
          
          <var>value</var>. 
          
          
          
          <var>False</var> indicates a timeout or cancel.

In the other overloaded version, see 
          
          
          
          <link id="TGpioPollResult"/> for documentation.</descr>
      </element>
      <element name="TGpioGroup">
        <short>Group of joint GPIO pins</short>
        <descr>Some GPIO expanders allow the manipulation of a group of pins only. Only the group may be configured as output or input---not each pin individually.</descr>
      </element>
      <element name="TGpioPin.WaitForInterruptIndirect.timeout">
        <short>Timeout in milliseconds</short>
      </element>
      <element name="TGpioPin.WaitForInterrupt.timeout">
        <short>Timeout in milliseconds</short>
      </element>
      <short>General Purpose Input/Output access classes for Free Pascal</short>
      <element name="TGpioDirection.gdOut">
        <short>GPIO in output mode</short>
        <seealso>
          <link id="TGpioDirection.gdIn"/>
          <link id="TGpioPin.Direction"/>
        </seealso>
      </element>
      <element name="TGpioDirection.gdIn">
        <short>GPIO in input mode</short>
        <seealso>
          <link id="TGpioDirection.gdOut"/>
          <link id="TGpioPin.Direction"/>
        </seealso>
      </element>
      <element name="TGpioDirection">
        <short>Direction of GPIO Pins</short>
        <seealso>
          <link id="TGpioPin.Direction"/>
        </seealso>
      </element>
      <element name="TGpioPin.Direction">
        <short>Configure pin as Input or as Output</short>
      </element>
      <element name="TGpioInterruptModes">
        <short>Basic interrupt condition</short>
      </element>
      <element name="TGpioInterruptMode">
        <short>Combination of Interrupt modes</short>
      </element>
      <element name="gimBoth">
        <short>Interrupt on rising edge and on falling edge</short>
      </element>
      <element name="gimNone">
        <short>No interrupt</short>
      </element>
      <element name="TGpioPin.WaitForInterrupt">
        <short>Waits for interrupt</short>
        <errors>If (direct) interrupts are not supported (e.g. I/O expanders), an <link id="EDirectInterruptError"/> exception is raised.</errors>
        <seealso>
          <link id="TGpioPin.InterruptMode"/>
        </seealso>
      </element>
      <element name="EDirectInterruptError">
        <short>Interrupt not supported</short>
      </element>
      <element name="EIndirectInterruptError">
        <short>Indirect Interrupt not supported</short>
      </element>
      <element name="TGpioPin.WaitForInterruptIndirect">
        <short>Waits for indirect interrupt</short>
        <descr>A change on a pin of an I/O expander can't be detected by the host. So most (or at least some of them) can be configured to indicate a change on a outgoing interrupt pin. The provided TGpioPin object has to be fully configured.</descr>
      </element>
      <element name="TGpioPin.WaitForInterruptIndirect.aInterruptPin"/>
      <element name="TGpioPin.AcitveHigh">
        <short>Invert logic value</short>
      </element>
      <element name="TGpioInterruptModes.gimRising">
        <short>Interrupt on rising edge</short>
      </element>
      <element name="TGpioInterruptModes.gimFalling">
        <short>Interrupt on falling edge</short>
      </element>
      <element name="EInterruptError">
        <short>Generic exception for interrupt errors</short>
      </element>
      <element name="TGpioPin.InterruptMode">
        <short>Interrupt mode</short>
      </element>
      <element name="TGpioController">
        <short>Generic class for a goup of GPIO pins controlled together</short>
      </element>
      <element name="TPinPosition">
        <short>All possible positions of a Pin in a Register</short>
        <seealso>
          <link id="TRegisterValue"/>
        </seealso>
      </element>
      <element name="TRegisterValue">
        <short>Value of a 8 bit register</short>
        <seealso>
          <link id="TPinPosition"/>
        </seealso>
      </element>
      <element name="TRegisterType">
        <short>All register types a I/O expander might support</short>
        <seealso>
          <link id="TGpioRegisterController.GetRegister"/>
        </seealso>
        <descr>This enumeration contains all possible types of registers an I/O expander might have. These types are named by usage. Thus a microcontroller may have seperate registers for setting and reading a GPIO pins value.

A register type is converted to an address which an I/O expander can understand within <link id="TGpioRegisterController.GetRegister"/>.</descr>
      </element>
      <element name="TGpioRegisterController">
        <short>Generic class for I/O controller using registers</short>
        <descr>
          <p>Many external I/O expanders provide an interface which exposes the internal registers to the contoller. This base class provides an basic interface to these I/O expanders.</p>
          <p>Setting and getting values basically operate on 3 methods:</p>
          <ol>
            <li>
              <link id="TGpioRegisterController.GetRegister">function GetRegister():</link> Getting the              
              
    
              
              
              
              
              
              
              <link id="TRegisterAddress">adress of the register</link> and the 
              
              
    
              
              
              
              
              
              
              <link id="TPinPosition">position of the pin within this register</link>.</li>
            <li>
              <link id="TGpioRegisterController.GetRegisterValue">function GetRegisterValue():</link> Reading the current 
              
              
    
              
              
              
              
              
              
              <link id="TRegisterValue"/>.</li>
            <li>
              <link id="TGpioRegisterController.SetRegisterValue">procedure SetRegisterValue():</link> Setting the new value if desired.</li>
            <li>If you are interested in only one bit of a register, you may use the convenience methods <link id="TGpioRegisterController.GetRegisterValueS"/> and <link id="TGpioRegisterController.SetRegisterValueS"/>.</li>
          </ol>
          <p>
            <b>Only expanders with 8 bit registers are supported.</b> This does not mean, the expander may have at maximum 8 GPIO channels. An expander may provide more than one register for one task.</p>
        </descr>
      </element>
      <element name="TGpioRegisterController.GetRegister">
        <short>Address of a requested register</short>
        <descr>Has to be implemented!</descr>
      </element>
      <element name="TGpioRegisterController.GetRegisterValue">
        <descr>Has to be implemented!</descr>
        <short>Retrieves the value of a given register</short>
      </element>
      <element name="TGpioRegisterController.SetRegisterValue">
        <short>Set the value of a given register</short>
        <descr>Has to be implemented!</descr>
      </element>
      <element name="TGpioRegisterController.RegisterValue">
        <short>Value of a given register</short>
      </element>
      <element name="TGpioController.Pins">
        <short>All pins in this controller</short>
        <seealso>
          <link id="TGpioControlledPin"/>
        </seealso>
        <descr>The controller holds all pins which it controls. The pins are of the class <link id="TGpioControlledPin"/>, which is a special implementation for this controller class (but who cares---it has no special abilities).</descr>
      </element>
      <element name="TGpioController.Count">
        <short>Count of pins</short>
      </element>
      <element name="TGpioController.ActiveLow">
        <short>Inverted logic</short>
      </element>
      <element name="TGpioController.Value">
        <short>Value of pin</short>
      </element>
      <element name="TGpioController.Direction">
        <short>Direction of pin</short>
      </element>
      <element name="TGpioController.Create">
        <short>Creates required Pin instances</short>
        <descr>Has to be overridden!</descr>
      </element>
      <element name="TGpioControlledPin">
        <short>GPIO pin class for TGPIOController</short>
        <descr>This class is an implementation for <link id="TGpioController"/>. All actions are forwarded to the controller.</descr>
        <seealso>
          <link id="TGpioController"/>
        </seealso>
      </element>
      <element name="TRegisterType.rtGetValue">
        <short>Register for getting the values</short>
      </element>
      <element name="TGpioRegisterController.GetRegisterValueS">
        <short>Convenience method for getting a value for a specific pin</short>
        <seealso>
          <link id="TGpioRegisterController.SetRegisterValueS"/>
          <link id="TGpioRegisterController.GetRegister"/>
          <link id="TGpioRegisterController.GetRegisterValue"/>
        </seealso>
      </element>
      <element name="TGpioRegisterController.SetRegisterValueS">
        <short>Convenience method for setting a value for a specific pin</short>
        <seealso>
          <link id="TGpioRegisterController.GetRegisterValueS"/>
          <link id="TGpioRegisterController.GetRegister"/>
          <link id="TGpioRegisterController.GetRegisterValue"/>
          <link id="TGpioRegisterController.SetRegisterValue"/>
        </seealso>
      </element>
      <element name="TRegisterAddress">
        <short>Register address in expander</short>
      </element>
      <element name="TGpioLinuxPin">
        <short>Implementation using the Linux Kernel Driver</short>
        <descr>The Linux Kernel exposes GPIO pins to user mode applications through the filesystem interface located at /sys/class/gpio/. This is used by this class.

This class should be threadsafe (not tested!). You should be able to read values in one thread while another thread is waiting for an interrupt.</descr>
      </element>
      <element name="TGpioLinuxPin.Create">
        <short>Creates a new instance</short>
      </element>
      <element name="TGpioLinuxPin.Create.aID">
        <short>GPIO pin ID</short>
        <descr>This the internal Pin ID of the microcontroller running Linux. Typically it is <b>not </b>any Pin number printed on the board.

Regarding the Raspberry Pi, this is the BCM pin number, not the one of the connectors.</descr>
      </element>
      <element name="GPIO_LINUX_BASE_DIR">
        <short>Base directory for Linux Kernel GPIO interface</short>
      </element>
      <element name="GPIO_LINUX_GPIOPIN_DIR">
        <short>Base directory for Linux Kernel GPIO interface for specific Pin</short>
      </element>
      <element name="TGpioControlledPin.Create">
        <short>Creates new controlled GPIO pin</short>
        <descr>This constructor should be called by <link id="TGpioController.Create"/> only.</descr>
      </element>
      <element name="TGpioControlledPin.Create.aController">
        <short>Responsible Controller for this pin</short>
      </element>
      <element name="TGpioControlledPin.Create.aIndex">
        <short>Internal index of this pin</short>
      </element>
      <element name="TGpioLinuxPin.PinID">
        <short>The GPIO's ID in the Linux Kernel driver</short>
        <seealso>
          <link id="TGpioLinuxPin.Create"/>
        </seealso>
      </element>
      <element name="TGpioPin.PollChange.OnIdle">
        <short>Callback after each poll</short>
      </element>
      <element name="TGpioPollIdle">
        <short>Callback for PollChange</short>
        <descr>This callback is called after each poll.</descr>
        <seealso>
          <link id="TGpioPin.PollChange"/>
        </seealso>
      </element>
      <element name="TGpioPollIdle.Sender">
        <short>GPIO Pin</short>
        <descr>GPIO Pin which issues this calllback</descr>
        <seealso>
          <link id="TGpioPin.PollChange"/>
        </seealso>
      </element>
      <element name="TGpioPollIdle.CancelPoll">
        <short>User cancel poll</short>
        <descr>Set 
<var>CancelPoll</var> to 
<var>True</var> to cancel the current poll. Set to 
<var>False</var> if you want to poll one more time---given that the timeout has not been reached.</descr>
        <seealso>
          <link id="TGpioPin.PollChange"/>
          <link id="TGpioPin.PollChange.timeout"/>
        </seealso>
      </element>
      <element name="TGpioPollResult">
        <short>Result of PollChange</short>
        <descr>Indicates the return reason of <link id="TGpioPin.PollChange"/>
        </descr>
        <seealso>
          <link id="TGpioPin.PollChange"/>
        </seealso>
      </element>
      <element name="TGpioPollResult.gprChanged">
        <short>Value changed</short>
        <descr>The value has changed.</descr>
      </element>
      <element name="TGpioPollResult.gprTimeout">
        <short>Timeout expired</short>
        <descr>No change on value since start</descr>
      </element>
      <element name="TGpioPollResult.gprCancelled">
        <short>Cancelled during callback</short>
        <seealso>
          <link id="TGpioPin.PollChange.OnIdle"/>
        </seealso>
      </element>
    </module><module name="fpi2c">
      <element name="sI2CSlaveAddress">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="sI2CWrite">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- resource string Visibility: default -->
      <element name="rsBufferNotSet">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- resource string Visibility: default -->
      <element name="rsBufferToLarge">
        <short>Buffer is not 1 byte in length</short>
        <seealso>
          <link id="EI2CQueueObjectInconsistency"/>
          <link id="TI2CQueueObject.CheckConsistency"/>
          <link id="TI2CQueueObject.UseCommand"/>
        </seealso>
      </element>
      <!-- resource string Visibility: default -->
      <element name="rsReadWriteBitSet">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TI2CAddress">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- alias type Visibility: default -->
      <element name="TI2CRegister">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- class Visibility: default -->
      <element name="EI2CQueueObjectInconsistency">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- class Visibility: default -->
      <element name="TI2CQueueObject">
        <short>Description of a queued action on a I2C bus</short>
        <descr>This object describes a read or write request on an <link id="TI2CBus">I2C bus</link>. The <link id="TI2CThreadSaveDevice"/> queues all it's actions on a bus; use this class as an example usage.</descr>
        <seealso>
          <link id="TI2CBus"/>
          <link id="TI2CBus.QueueObject"/>
          <link id="TI2CThreadSaveDevice"/>
        </seealso>
      </element>
      <!-- range type Visibility: public -->
      <element name="TI2CQueueObject.TBufferLength">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TI2CQueueObject.fFatalException">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TI2CQueueObject.fReadyEvent">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TI2CQueueObject.fWriteEvent">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TI2CQueueObject.fAddress">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TI2CQueueObject.fCommand">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TI2CQueueObject.fUseCommand">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TI2CQueueObject.fRead">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TI2CQueueObject.fBufLen">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TI2CQueueObject.fBuffer">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TI2CQueueObject.SetCommand">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: private -->
      <element name="TI2CQueueObject.SetCommand.aValue">
        <short/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TI2CQueueObject.Create">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- destructor Visibility: public -->
      <element name="TI2CQueueObject.Destroy">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TI2CQueueObject.CheckConsistency">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TI2CQueueObject.WaitForWrite">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TI2CQueueObject.SetDataWritten">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TI2CQueueObject.SetReadBufferLength">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: public -->
      <element name="TI2CQueueObject.SetReadBufferLength.aLen">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TI2CQueueObject.SetWriteBuffer">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: public -->
      <element name="TI2CQueueObject.SetWriteBuffer.aBuf">
        <short/>
      </element>
      <!-- argument Visibility: public -->
      <element name="TI2CQueueObject.SetWriteBuffer.aLen">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TI2CQueueObject.SetResultBuffer">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: public -->
      <element name="TI2CQueueObject.SetResultBuffer.aBuf">
        <short/>
      </element>
      <!-- argument Visibility: public -->
      <element name="TI2CQueueObject.SetResultBuffer.aLen">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TI2CQueueObject.GetResultBuffer">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: public -->
      <element name="TI2CQueueObject.GetResultBuffer.Result">
        <short/>
      </element>
      <!-- argument Visibility: public -->
      <element name="TI2CQueueObject.GetResultBuffer.aBuf">
        <short/>
      </element>
      <!-- argument Visibility: public -->
      <element name="TI2CQueueObject.GetResultBuffer.aLen">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TI2CQueueObject.GetWriteBuffer">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: public -->
      <element name="TI2CQueueObject.GetWriteBuffer.aBuf">
        <short/>
      </element>
      <!-- argument Visibility: public -->
      <element name="TI2CQueueObject.GetWriteBuffer.aMaxLen">
        <short/>
      </element>
      <!-- argument Visibility: public -->
      <element name="TI2CQueueObject.GetWriteBuffer.aLen">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TI2CQueueObject.BufferLength">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TI2CQueueObject.Address">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TI2CQueueObject.Read">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TI2CQueueObject.Command">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TI2CQueueObject.UseCommand">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TI2CQueueObject.FatalException">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- class Visibility: default -->
      <element name="TI2CBus">
        <short>Threadsafe I2C Bus</short>
        <descr>One I2C bus is connected to several devices. This object is threadsafe.</descr>
      </element>
      <!-- variable Visibility: strict private -->
      <element name="TI2CBus.fBus">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: protected -->
      <element name="TI2CBus.fQueue">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: protected -->
      <element name="TI2CBus.fThreadWakeup">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TI2CBus.Execute">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TI2CBus.ProcessObject">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: protected -->
      <element name="TI2CBus.ProcessObject.aObj">
        <short/>
      </element>
      <!-- property Visibility: protected -->
      <element name="TI2CBus.Queue">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TI2CBus.Create">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: public -->
      <element name="TI2CBus.Create.aBus">
        <short/>
      </element>
      <!-- destructor Visibility: public -->
      <element name="TI2CBus.Destroy">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TI2CBus.QueueObject">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: public -->
      <element name="TI2CBus.QueueObject.aObj">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TI2CBus.ReadByte">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: public -->
      <element name="TI2CBus.ReadByte.Result">
        <short/>
      </element>
      <!-- argument Visibility: public -->
      <element name="TI2CBus.ReadByte.aAddress">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TI2CBus.WriteByte">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: public -->
      <element name="TI2CBus.WriteByte.aAddress">
        <short/>
      </element>
      <!-- argument Visibility: public -->
      <element name="TI2CBus.WriteByte.aByte">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TI2CBus.ReadRegByte">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: public -->
      <element name="TI2CBus.ReadRegByte.Result">
        <short/>
      </element>
      <!-- argument Visibility: public -->
      <element name="TI2CBus.ReadRegByte.aAddress">
        <short/>
      </element>
      <!-- argument Visibility: public -->
      <element name="TI2CBus.ReadRegByte.aRegister">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TI2CBus.ReadRegWord">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: public -->
      <element name="TI2CBus.ReadRegWord.Result">
        <short/>
      </element>
      <!-- argument Visibility: public -->
      <element name="TI2CBus.ReadRegWord.aAddress">
        <short/>
      </element>
      <!-- argument Visibility: public -->
      <element name="TI2CBus.ReadRegWord.aRegister">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TI2CBus.WriteRegByte">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: public -->
      <element name="TI2CBus.WriteRegByte.aAddress">
        <short/>
      </element>
      <!-- argument Visibility: public -->
      <element name="TI2CBus.WriteRegByte.aRegister">
        <short/>
      </element>
      <!-- argument Visibility: public -->
      <element name="TI2CBus.WriteRegByte.aByte">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TI2CBus.WriteRegWord">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: public -->
      <element name="TI2CBus.WriteRegWord.aAddress">
        <short/>
      </element>
      <!-- argument Visibility: public -->
      <element name="TI2CBus.WriteRegWord.aRegister">
        <short/>
      </element>
      <!-- argument Visibility: public -->
      <element name="TI2CBus.WriteRegWord.aWord">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TI2CBus.ReadBlockData">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: public -->
      <element name="TI2CBus.ReadBlockData.Result">
        <short/>
      </element>
      <!-- argument Visibility: public -->
      <element name="TI2CBus.ReadBlockData.aAddress">
        <short/>
      </element>
      <!-- argument Visibility: public -->
      <element name="TI2CBus.ReadBlockData.aRegister">
        <short/>
      </element>
      <!-- argument Visibility: public -->
      <element name="TI2CBus.ReadBlockData.aBuffer">
        <short/>
      </element>
      <!-- argument Visibility: public -->
      <element name="TI2CBus.ReadBlockData.aCount">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TI2CBus.WriteBlockData">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: public -->
      <element name="TI2CBus.WriteBlockData.aAddress">
        <short/>
      </element>
      <!-- argument Visibility: public -->
      <element name="TI2CBus.WriteBlockData.aRegister">
        <short/>
      </element>
      <!-- argument Visibility: public -->
      <element name="TI2CBus.WriteBlockData.Buffer">
        <short/>
      </element>
      <!-- argument Visibility: public -->
      <element name="TI2CBus.WriteBlockData.aCount">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TI2CBus.Bus">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TI2CDevice">
        <short>Abstract I2C device class</short>
        <descr>This class is an abstact interface for sending data to and receiving data from a I2C device attached to an I2C Bus.

If you are using only one device in your application, you should use a derived class, e.g. 
<link id="TI2CLinuxDevice"/>.

If there are multiple conccurrent threads in your multi threaded application accessing on bus, you may want to use 
<link id="TI2CBus"/> for request serialization. As an alternative, you should be able to create multiple instances of 
<link id="TI2CDevice"/>---one for each device (not tested).

This class is 
<b>not threadsafe</b>.</descr>
      </element>
      <element name="TI2CDevice.fAddress">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TI2CDevice.Create">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TI2CDevice.SetAddress">
        <short>Set device addresse</short>
        <descr>Usually it's a better idea to create one object for each device but for some reasons you may want to use only one object and change the address.</descr>
      </element>
      <!-- argument Visibility: protected -->
      <element name="TI2CDevice.SetAddress.aValue">
        <short>New address</short>
      </element>
      <element name="TI2CDevice.Create.aAddress">
        <short/>
      </element>
      <element name="TI2CDevice.ReadByte">
        <short>Read single byte</short>
        <descr>Reads a single byte from the device</descr>
      </element>
      <element name="TI2CDevice.ReadByte.Result">
        <short/>
      </element>
      <element name="TI2CDevice.WriteByte">
        <short>Writes a single byte to the device</short>
      </element>
      <element name="TI2CDevice.WriteByte.aByte">
        <short/>
      </element>
      <element name="TI2CDevice.ReadRegByte">
        <short>Read byte from register</short>
        <descr>Reads a single byte from a register</descr>
      </element>
      <element name="TI2CDevice.ReadRegByte.Result">
        <short/>
      </element>
      <element name="TI2CDevice.ReadRegByte.aRegister">
        <short>Register to read from</short>
      </element>
      <element name="TI2CDevice.ReadRegWord">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TI2CDevice.ReadRegWord.Result">
        <short/>
      </element>
      <element name="TI2CDevice.ReadRegWord.aRegsiter">
        <short>Register to read from</short>
      </element>
      <element name="TI2CDevice.WriteRegByte">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TI2CDevice.WriteRegByte.aRegister">
        <short>Register to write to</short>
      </element>
      <element name="TI2CDevice.WriteRegByte.aByte">
        <short/>
      </element>
      <element name="TI2CDevice.WriteRegWord">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TI2CDevice.WriteRegWord.aRegister">
        <short>Register to write to</short>
      </element>
      <element name="TI2CDevice.WriteRegWord.aWord">
        <short/>
      </element>
      <element name="TI2CDevice.ReadBlockData">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TI2CDevice.ReadBlockData.aRegister">
        <short/>
      </element>
      <element name="TI2CDevice.ReadBlockData.aBuffer">
        <short/>
      </element>
      <element name="TI2CDevice.ReadBlockData.aCount">
        <short/>
      </element>
      <element name="TI2CDevice.WriteData">
        <short>Write data of arbitrary length to a register</short>
      </element>
      <element name="TI2CDevice.WriteData.aRegister">
        <short>Register to write to</short>
      </element>
      <element name="TI2CDevice.WriteData.Buffer">
        <short>Data to be written</short>
      </element>
      <element name="TI2CDevice.WriteData.aCount">
        <short>Length of Buffer in bytes</short>
        <seealso>
          <link id="TI2CDevice.WriteData.Buffer">Buffer</link>
        </seealso>
      </element>
      <element name="TI2CDevice.WriteWord">
        <short>Writes word to a register</short>
      </element>
      <element name="TI2CDevice.WriteWord.aRegister">
        <short>Register to write to</short>
      </element>
      <element name="TI2CDevice.WriteWord.aWord">
        <short/>
      </element>
      <element name="TI2CDevice.WriteLongWord">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TI2CDevice.WriteLongWord.aRegsiter">
        <short>Register to write to</short>
      </element>
      <element name="TI2CDevice.WriteLongWord.aLongWord">
        <short/>
      </element>
      <element name="TI2CDevice.WriteQWord">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TI2CDevice.WriteQWord.aRegister">
        <short>Register to write to</short>
      </element>
      <element name="TI2CDevice.WriteQWord.aQWord">
        <short/>
      </element>
      <element name="TI2CDevice.Address">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- class Visibility: default -->
      <element name="TI2CThreadSaveDevice">
        <short>Thread safe I2C Device</short>
      </element>
      <!-- variable Visibility: strict private -->
      <element name="TI2CThreadSaveDevice.fBus">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TI2CThreadSaveDevice.Create">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: public -->
      <element name="TI2CThreadSaveDevice.Create.aAddress">
        <short/>
      </element>
      <!-- argument Visibility: public -->
      <element name="TI2CThreadSaveDevice.Create.aBus">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TI2CThreadSaveDevice.ReadBlockData">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: public -->
      <element name="TI2CThreadSaveDevice.ReadBlockData.Result">
        <short/>
      </element>
      <!-- argument Visibility: public -->
      <element name="TI2CThreadSaveDevice.ReadBlockData.aRegister">
        <short/>
      </element>
      <!-- argument Visibility: public -->
      <element name="TI2CThreadSaveDevice.ReadBlockData.aBuffer">
        <short/>
      </element>
      <!-- argument Visibility: public -->
      <element name="TI2CThreadSaveDevice.ReadBlockData.aCount">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TI2CThreadSaveDevice.ReadByte">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: public -->
      <element name="TI2CThreadSaveDevice.ReadByte.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TI2CThreadSaveDevice.ReadRegByte">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: public -->
      <element name="TI2CThreadSaveDevice.ReadRegByte.Result">
        <short/>
      </element>
      <!-- argument Visibility: public -->
      <element name="TI2CThreadSaveDevice.ReadRegByte.aRegister">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TI2CThreadSaveDevice.ReadRegWord">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: public -->
      <element name="TI2CThreadSaveDevice.ReadRegWord.Result">
        <short/>
      </element>
      <!-- argument Visibility: public -->
      <element name="TI2CThreadSaveDevice.ReadRegWord.aRegister">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TI2CThreadSaveDevice.WriteBlockData">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: public -->
      <element name="TI2CThreadSaveDevice.WriteBlockData.aRegister">
        <short/>
      </element>
      <!-- argument Visibility: public -->
      <element name="TI2CThreadSaveDevice.WriteBlockData.Buffer">
        <short/>
      </element>
      <!-- argument Visibility: public -->
      <element name="TI2CThreadSaveDevice.WriteBlockData.aCount">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TI2CThreadSaveDevice.WriteByte">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: public -->
      <element name="TI2CThreadSaveDevice.WriteByte.aByte">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TI2CThreadSaveDevice.WriteRegByte">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: public -->
      <element name="TI2CThreadSaveDevice.WriteRegByte.aRegister">
        <short/>
      </element>
      <!-- argument Visibility: public -->
      <element name="TI2CThreadSaveDevice.WriteRegByte.aByte">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TI2CThreadSaveDevice.WriteRegWord">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: public -->
      <element name="TI2CThreadSaveDevice.WriteRegWord.aRegister">
        <short/>
      </element>
      <!-- argument Visibility: public -->
      <element name="TI2CThreadSaveDevice.WriteRegWord.aWord">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TI2CThreadSaveDevice.Bus">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TI2CLinuxDevice">
        <short>Accesing I2C bus using Linux File interface</short>
        <descr>
          <p>This class implements the access to a single I2C device using Linux' file system interface.</p>
          <p>Please check you have loaded the Kernel module

<url href="http://www.mjmwired.net/kernel/Documentation/i2c/dev-interface">i2c-dev</url> before creating an instance of this class. This module creates the /dev/i2c-* files, which are used by user space programms (like yours).

You may need to load another kernel module, for making the I2C busses accessible by the kernel itself.
</p>
          <table>
            <tr>
              <td>Board</td>
              <td>SoC</td>
              <td>Kernel Module</td>
            </tr>
            <tr>
              <td>Raspberry Pi (all revisions)</td>
              <td>BCM2835</td>
              <td>i2c-bcm2708 </td>
            </tr>
          </table>
        </descr>
      </element>
      <element name="TI2CLinuxDevice.fHandle">
        <short>File handle</short>
      </element>
      <element name="TI2CLinuxDevice.Create">
        <short>Create new Linux device</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TI2CLinuxDevice.Create.aAddress">
        <short>Address of the device</short>
      </element>
      <element name="TI2CLinuxDevice.Create.aBusID">
        <short>I2C Bus ID</short>
      </element>
      <element name="TI2CLinuxDevice.ReadBlockData">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TI2CLinuxDevice.ReadBlockData.Result">
        <short/>
      </element>
      <element name="TI2CLinuxDevice.ReadBlockData.aRegister">
        <short/>
      </element>
      <element name="TI2CLinuxDevice.ReadBlockData.aBuffer">
        <short/>
      </element>
      <element name="TI2CLinuxDevice.ReadBlockData.aCount">
        <short/>
      </element>
      <element name="TI2CLinuxDevice.ReadByte">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TI2CLinuxDevice.ReadByte.Result">
        <short/>
      </element>
      <element name="TI2CLinuxDevice.ReadRegByte">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TI2CLinuxDevice.ReadRegByte.Result">
        <short/>
      </element>
      <element name="TI2CLinuxDevice.ReadRegByte.aRegister">
        <short/>
      </element>
      <element name="TI2CLinuxDevice.ReadRegWord">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TI2CLinuxDevice.ReadRegWord.Result">
        <short/>
      </element>
      <element name="TI2CLinuxDevice.ReadRegWord.aRegsiter">
        <short/>
      </element>
      <element name="TI2CLinuxDevice.WriteByte">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TI2CLinuxDevice.WriteByte.aByte">
        <short/>
      </element>
      <element name="TI2CLinuxDevice.WriteData">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TI2CLinuxDevice.WriteData.aRegister">
        <short/>
      </element>
      <element name="TI2CLinuxDevice.WriteData.Buffer">
        <short/>
      </element>
      <element name="TI2CLinuxDevice.WriteData.aCount">
        <short/>
      </element>
      <element name="TI2CLinuxDevice.WriteRegByte">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TI2CLinuxDevice.WriteRegByte.aRegister">
        <short/>
      </element>
      <element name="TI2CLinuxDevice.WriteRegByte.aByte">
        <short/>
      </element>
      <element name="TI2CLinuxDevice.WriteRegWord">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TI2CLinuxDevice.WriteRegWord.aRegister">
        <short/>
      </element>
      <element name="TI2CLinuxDevice.WriteRegWord.aWord">
        <short/>
      </element>
      <element name="TI2CLinuxDevice.Handle">
        <short>File Handle</short>
      </element>
      <short>Free Pascal I2C abstraction layer</short>
    </module><module name="fpspi">
      <element name="rsSPIIoCtlErr">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TSPIMode">
        <short>Settings for the SPI mode</short>
        <descr/>
        <seealso>
          <link id="SPI_MODE_0"/>
          <link id="SPI_MODE_1"/>
          <link id="SPI_MODE_2"/>
          <link id="SPI_MODE_3"/>
          <link id="TSPIDevice.Mode"/>
        </seealso>
      </element>
      <element name="TSPIMode.SPI_CPHA">
        <short>Clock Phase</short>
      </element>
      <element name="TSPIMode.SPI_CPOL">
        <short>Clock Polarity</short>
      </element>
      <element name="SPI_MODE_0">
        <short>SPI Mode 0 - CPOL=0, CPHA=0</short>
        <descr>
          <table>
            <th>
              <td>Mode</td>
              <td>Clock Polarity (CPOL)</td>
              <td>Clock Phase (CPHA)</td>
            </th>
            <tr>
              <td>0</td>
              <td>0</td>
              <td>0</td>
            </tr>
            <tr>
              <td>1</td>
              <td>0</td>
              <td>1</td>
            </tr>
            <tr>
              <td>2</td>
              <td>1</td>
              <td>0</td>
            </tr>
            <tr>
              <td>3</td>
              <td>1</td>
              <td>1</td>
            </tr>
          </table>
        </descr>
        <seealso>
          <link id="SPI_MODE_0"/>
          <link id="SPI_MODE_1"/>
          <link id="SPI_MODE_2"/>
          <link id="SPI_MODE_3"/>
          <link id="TSPIMode"/>
        </seealso>
      </element>
      <element name="SPI_MODE_1">
        <short>SPI Mode 0 - CPOL=0, CPHA=1</short>
        <descr>
          <table>
            <th>
              <td>Mode</td>
              <td>Clock Polarity (CPOL)</td>
              <td>Clock Phase (CPHA)</td>
            </th>
            <tr>
              <td>0</td>
              <td>0</td>
              <td>0</td>
            </tr>
            <tr>
              <td>1</td>
              <td>0</td>
              <td>1</td>
            </tr>
            <tr>
              <td>2</td>
              <td>1</td>
              <td>0</td>
            </tr>
            <tr>
              <td>3</td>
              <td>1</td>
              <td>1</td>
            </tr>
          </table>
        </descr>
        <seealso>
          <link id="SPI_MODE_0"/>
          <link id="SPI_MODE_1"/>
          <link id="SPI_MODE_2"/>
          <link id="SPI_MODE_3"/>
          <link id="TSPIMode"/>
        </seealso>
      </element>
      <element name="SPI_MODE_2">
        <short>SPI Mode 0 - CPOL=1, CPHA=0</short>
        <descr>
          <table>
            <th>
              <td>Mode</td>
              <td>Clock Polarity (CPOL)</td>
              <td>Clock Phase (CPHA)</td>
            </th>
            <tr>
              <td>0</td>
              <td>0</td>
              <td>0</td>
            </tr>
            <tr>
              <td>1</td>
              <td>0</td>
              <td>1</td>
            </tr>
            <tr>
              <td>2</td>
              <td>1</td>
              <td>0</td>
            </tr>
            <tr>
              <td>3</td>
              <td>1</td>
              <td>1</td>
            </tr>
          </table>
        </descr>
        <seealso>
          <link id="SPI_MODE_0"/>
          <link id="SPI_MODE_1"/>
          <link id="SPI_MODE_2"/>
          <link id="SPI_MODE_3"/>
          <link id="TSPIMode"/>
        </seealso>
      </element>
      <element name="SPI_MODE_3">
        <short>SPI Mode 0 - CPOL=1, CPHA=1</short>
        <descr>
          <table>
            <th>
              <td>Mode</td>
              <td>Clock Polarity (CPOL)</td>
              <td>Clock Phase (CPHA)</td>
            </th>
            <tr>
              <td>0</td>
              <td>0</td>
              <td>0</td>
            </tr>
            <tr>
              <td>1</td>
              <td>0</td>
              <td>1</td>
            </tr>
            <tr>
              <td>2</td>
              <td>1</td>
              <td>0</td>
            </tr>
            <tr>
              <td>3</td>
              <td>1</td>
              <td>1</td>
            </tr>
          </table>
        </descr>
        <seealso>
          <link id="SPI_MODE_0"/>
          <link id="SPI_MODE_1"/>
          <link id="SPI_MODE_2"/>
          <link id="SPI_MODE_3"/>
          <link id="TSPIMode"/>
        </seealso>
      </element>
      <element name="TSPIDevice">
        <short>Abstract SPI device</short>
      </element>
      <element name="TSPIDevice.GetBitsPerWord">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TSPIDevice.GetBitsPerWord.Result">
        <short/>
      </element>
      <element name="TSPIDevice.SetBitsPerWord">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TSPIDevice.SetBitsPerWord.AValue">
        <short/>
      </element>
      <element name="TSPIDevice.GetLSBFirst">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TSPIDevice.GetLSBFirst.Result">
        <short/>
      </element>
      <element name="TSPIDevice.GetMaxFrequency">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TSPIDevice.GetMaxFrequency.Result">
        <short/>
      </element>
      <element name="TSPIDevice.GetMode">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TSPIDevice.GetMode.Result">
        <short/>
      </element>
      <element name="TSPIDevice.SetLSBFirst">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TSPIDevice.SetLSBFirst.AValue">
        <short/>
      </element>
      <element name="TSPIDevice.SetMaxFrequency">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TSPIDevice.SetMaxFrequency.AValue">
        <short/>
      </element>
      <element name="TSPIDevice.SetMode">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TSPIDevice.SetMode.AValue">
        <short/>
      </element>
      <element name="TSPIDevice.ReadAndWrite">
        <short>Bidirectional read and write</short>
        <descr>
          <p>This method allows simultanous read and write acces to the SPI bus.</p>
          <p>The buffer sizes may not be equal.  If the write buffer is the smaller one, all futher bytes will be filled with zeroes. If the read buffer is the smaller one, more bytes may be read from the device but will not be reported back to the caller.</p>
          <remark>Please check your SPI device's manual, if this behaviour is supported. Otherwise provide read and write buffers with the same length and handle them in your application's code.</remark>
        </descr>
        <errors/>
        
      </element>
      <element name="TSPIDevice.ReadAndWrite.aWriteBuffer">
        <short>Data written to the bus</short>
      </element>
      <element name="TSPIDevice.ReadAndWrite.aWriteCount">
        <short>Count of bytes in buffer</short>
      </element>
      <element name="TSPIDevice.ReadAndWrite.aReadBuffer">
        <short>Data received from the bus</short>
      </element>
      <element name="TSPIDevice.ReadAndWrite.aReadCount">
        <short>Maximum bytes read</short>
      </element>
      <element name="TSPIDevice.Mode">
        <short>The SPI Mode</short>
        
        <seealso/>
      </element>
      <element name="TSPIDevice.LSBFirst">
        <short>Transfer the least or most significant bit first</short>
        <descr>By default, the most significant bit is transferred first.</descr>
        <seealso/>
      </element>
      <element name="TSPIDevice.MaxFrequency">
        <short>Maximum Frequency (Hz)</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TSPIDevice.BitsPerWord">
        <short>Count of bits transferred as smallest unit</short>
        <descr>Some SPI bus devices don't support other values than 8 bits per word. Therefore, 8 bits per word is the default setting.</descr>
        <seealso/>
      </element>
      <element name="TSPI_IOC_Transfer_Array">
        <short>Data structor passed to the Linux spidev driver</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TSPILinuxDevice">
        <short>SPI device for Linux</short>
        <descr>
          <p>This class implements the <link id="TSPIDevice"/> using the file system interface of the Linux kernel.</p>
        </descr>
      </element>
      <element name="TSPILinuxDevice.fBus">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TSPILinuxDevice.fCS">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TSPILinuxDevice.fHandle">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TSPILinuxDevice.GetBitsPerWord">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TSPILinuxDevice.GetBitsPerWord.Result">
        <short/>
      </element>
      <element name="TSPILinuxDevice.GetLSBFirst">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TSPILinuxDevice.GetLSBFirst.Result">
        <short/>
      </element>
      <element name="TSPILinuxDevice.GetMaxFrequency">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TSPILinuxDevice.GetMaxFrequency.Result">
        <short/>
      </element>
      <element name="TSPILinuxDevice.GetMode">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TSPILinuxDevice.GetMode.Result">
        <short/>
      </element>
      <element name="TSPILinuxDevice.SetBitsPerWord">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TSPILinuxDevice.SetBitsPerWord.AValue">
        <short/>
      </element>
      <element name="TSPILinuxDevice.SetLSBFirst">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TSPILinuxDevice.SetLSBFirst.AValue">
        <short/>
      </element>
      <element name="TSPILinuxDevice.SetMaxFrequency">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TSPILinuxDevice.SetMaxFrequency.AValue">
        <short/>
      </element>
      <element name="TSPILinuxDevice.SetMode">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TSPILinuxDevice.SetMode.AValue">
        <short/>
      </element>
      <element name="TSPILinuxDevice.GetDevicePath">
        <short>Returns the SPI devices file name in file system</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="TSPILinuxDevice.Bus"/>
          <link id="TSPILinuxDevice.ChipSelect"/>
        </seealso>
      </element>
      <element name="TSPILinuxDevice.GetDevicePath.Result">
        <short/>
      </element>
      <element name="TSPILinuxDevice.DoIoCtlError">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TSPILinuxDevice.DoIoCtlError.Ndx">
        <short/>
      </element>
      <element name="TSPILinuxDevice.Create">
        <short>Instantiates a new SPI device</short>
        <descr>
          <p>The values of <var>aBus</var> and <var>aChipSelect</var> are directly mapped to the file name /dev/spidevB.C with B = Bus and C = Chipselect provided by the Linux spidev driver.</p>
          <p>See <url href="https://www.kernel.org/doc/Documentation/spi/spidev">https://www.kernel.org/doc/Documentation/spi/spidev</url> for a documentation of the spidev driver.</p>
        </descr>
        <errors/>
        
      </element>
      <element name="TSPILinuxDevice.Create.aBus">
        <short>The bus number</short>
      </element>
      <element name="TSPILinuxDevice.Create.aChipSelect">
        <short>The chipselect number</short>
      </element>
      <element name="TSPILinuxDevice.Destroy">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TSPILinuxDevice.Read">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TSPILinuxDevice.Read.Result">
        <short/>
      </element>
      <element name="TSPILinuxDevice.Read.Buffer">
        <short/>
      </element>
      <element name="TSPILinuxDevice.Read.Count">
        <short/>
      </element>
      <element name="TSPILinuxDevice.Write">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TSPILinuxDevice.Write.Result">
        <short/>
      </element>
      <element name="TSPILinuxDevice.Write.Buffer">
        <short/>
      </element>
      <element name="TSPILinuxDevice.Write.Count">
        <short/>
      </element>
      <element link="#pascalio.fpspi.TSPIDevice.ReadAndWrite" name="TSPILinuxDevice.ReadAndWrite">
        <short>Bidirectional read and write</short>
        <descr/>
        
        
      </element>
      <element name="TSPILinuxDevice.ReadAndWrite.aWriteBuffer">
        <short>Data written to the bus</short>
      </element>
      <element name="TSPILinuxDevice.ReadAndWrite.aWriteCount">
        <short>Count of bytes in buffer</short>
      </element>
      <element name="TSPILinuxDevice.ReadAndWrite.aReadBuffer">
        <short>Data received from the bus</short>
      </element>
      <element name="TSPILinuxDevice.ReadAndWrite.aReadCount">
        <short>Maximum bytes read</short>
      </element>
      <element name="TSPILinuxDevice.ReadAndWrite.in_out_data">
        <short>Data structure passed to Linux spidev driver</short>
      </element>
      <element name="TSPILinuxDevice.Bus">
        <short>The bus ID</short>
        <descr>
          <p>The bus ID can only set by the <link id="TSPILinuxDevice.Create">constructor</link>
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TSPILinuxDevice.ChipSelect">
        <short>ID of the ChipSelect</short>
        <descr>
          <p>The ChipSelect ID can only set by the <link id="TSPILinuxDevice.Create">constructor</link>
          </p>
        </descr>
        <seealso/>
      </element>
      <short>Free Pascal SPI abstraction layer</short>
      <descr>
        <p>This unit provides an object oriented access to the <url href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus">Serial Peripheral Interface (SPI)</url>. The base class for accessing an SPI device is <link id="TSPIDevice"/>.</p>
        <p>The default implementation for Linux is <link id="TSPILinuxDevice"/>
        </p>
      </descr>
      <seealso>
        <link id="TSPIDevice"/>
        <link id="TSPILinuxDevice"/>
      </seealso>
    <element name="TSPIDevice.Read">
        <short>Half duplex read</short>
        <descr>All bytes transferred to the SPI device are set to 0.</descr>
        <seealso>
          <link id="TSPIDevice.Write"/>
          <link id="TSPIDevice.ReadAndWrite"/>
        </seealso>
      </element><element name="TSPIDevice.Write">
        <short>Half duplex write</short>
        <descr>All bytes sent by SPI device are ignored.</descr>
        <seealso>
          <link id="TSPIDevice.Read"/>
          <link id="TSPIDevice.ReadAndWrite"/>
        </seealso>
      </element>
    </module><module name="fpspilib">
      <element name="TMCP3008.Create">
        <short>Create new object</short>
      </element>
      <element name="TMCP3008.Create.aBus">
        <short>The SPI bus to operate on</short>
      </element>
      <element name="TMCP300X">
        <short>Generic class for MCP3004/MCP3008</short>
        <descr>This is an abstract class. Use a class for a specific device instead.</descr>
        <seealso>
          <link id="TMCP3004"/>
          <link id="TMCP3008"/>
        </seealso>
      </element>
      <element name="TMCP3008">
        <short>Analog/Digital Converter MCP3008</short>
      </element>
      <element name="TMCP3004">
        <short>Analog/Digital Converter MCP3004</short>
      </element>
      <element name="TMCP300X.Create"/>
      <element name="TMCP300X.Create.aBus">
        <short>Bus to communicate with device</short>
      </element>
      <short>Free Pascal SPI device library</short>
      <descr>This unit contains a collection of classes wicht access SPI devices</descr>
    </module><module name="gpioexp">
      <element name="TGpioI2CController">
        <short>Abstract class for I2C expander</short>
        <descr>All GPIO expander providing an I2C interface should inerhit from this class.</descr>
      </element>
      <element name="TGpioI2CController.fI2CDevice">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TGpioI2CController.I2C">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TGpioI2CController.Create">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TGpioI2CController.Create.aDevice">
        <short/>
      </element>
      <element name="TGpioSPIController">
        <short>Abstract class for SPI expander</short>
        <descr>All GPIO expander providing an SPI interface should inerhit from this class.</descr>
      </element>
      <element name="TGpioSPIController.fSPIDevice">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TGpioSPIController.SPI">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TGpioSPIController.Create">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TGpioSPIController.Create.aDevice">
        <short/>
      </element>
      <element name="TMCP23X17">
        <short>Generic Class for MCP23017 and MCP23018</short>
        <descr>This class is an 

<link id="fpgpio.TGpioController">TGpioController</link> wrapper for 

<link id="mcp23017.TMCP23X17Controller">TMCP23X17Controller</link>.</descr>
      </element>
      <element name="TMCP23X17.fmcp23X17">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TMCP23X17.GetActiveLow">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23X17.GetActiveLow.Result">
        <short/>
      </element>
      <element name="TMCP23X17.GetActiveLow.Index">
        <short/>
      </element>
      <element name="TMCP23X17.GetCount">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23X17.GetCount.Result">
        <short/>
      </element>
      <element name="TMCP23X17.GetDirection">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23X17.GetDirection.Result">
        <short/>
      </element>
      <element name="TMCP23X17.GetDirection.Index">
        <short/>
      </element>
      <element name="TMCP23X17.GetInterruptMode">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23X17.GetInterruptMode.Result">
        <short/>
      </element>
      <element name="TMCP23X17.GetInterruptMode.Index">
        <short/>
      </element>
      <element name="TMCP23X17.GetValue">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23X17.GetValue.Result">
        <short/>
      </element>
      <element name="TMCP23X17.GetValue.index">
        <short/>
      </element>
      <element name="TMCP23X17.SetActiveLow">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23X17.SetActiveLow.Index">
        <short/>
      </element>
      <element name="TMCP23X17.SetActiveLow.AValue">
        <short/>
      </element>
      <element name="TMCP23X17.SetDirection">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23X17.SetDirection.Index">
        <short/>
      </element>
      <element name="TMCP23X17.SetDirection.AValue">
        <short/>
      </element>
      <element name="TMCP23X17.SetInterruptMode">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23X17.SetInterruptMode.Index">
        <short/>
      </element>
      <element name="TMCP23X17.SetInterruptMode.AValue">
        <short/>
      </element>
      <element name="TMCP23X17.SetValue">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23X17.SetValue.index">
        <short/>
      </element>
      <element name="TMCP23X17.SetValue.aValue">
        <short/>
      </element>
      <element name="TMCP23X17.Create">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23X17.Create.aMCP23X17">
        <short/>
      </element>
      <element name="TMCP23017">
        <short>Gpio Controller class for MCP23017</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23017.fProxy">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TMCP23017.fMCP23X17Controller">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TMCP23017.GetActiveLow">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23017.GetActiveLow.Result">
        <short/>
      </element>
      <element name="TMCP23017.GetActiveLow.Index">
        <short/>
      </element>
      <element name="TMCP23017.GetCount">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23017.GetCount.Result">
        <short/>
      </element>
      <element name="TMCP23017.GetDirection">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23017.GetDirection.Result">
        <short/>
      </element>
      <element name="TMCP23017.GetDirection.Index">
        <short/>
      </element>
      <element name="TMCP23017.GetInterruptMode">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23017.GetInterruptMode.Result">
        <short/>
      </element>
      <element name="TMCP23017.GetInterruptMode.Index">
        <short/>
      </element>
      <element name="TMCP23017.GetValue">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23017.GetValue.Result">
        <short/>
      </element>
      <element name="TMCP23017.GetValue.Index">
        <short/>
      </element>
      <element name="TMCP23017.SetActiveLow">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23017.SetActiveLow.Index">
        <short/>
      </element>
      <element name="TMCP23017.SetActiveLow.AValue">
        <short/>
      </element>
      <element name="TMCP23017.SetDirection">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23017.SetDirection.Index">
        <short/>
      </element>
      <element name="TMCP23017.SetDirection.AValue">
        <short/>
      </element>
      <element name="TMCP23017.SetInterruptMode">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23017.SetInterruptMode.Index">
        <short/>
      </element>
      <element name="TMCP23017.SetInterruptMode.AValue">
        <short/>
      </element>
      <element name="TMCP23017.SetValue">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23017.SetValue.Index">
        <short/>
      </element>
      <element name="TMCP23017.SetValue.aValue">
        <short/>
      </element>
      <element name="TMCP23017.Create">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23017.Create.aDevice">
        <short/>
      </element>
      <element name="TMCP23017.Destroy">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23S17">
        <short>Gpio Controller class for MCP23S17</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23S17.fProxy">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TMCP23S17.fMCP23X17Controller">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TMCP23S17.GetActiveLow">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23S17.GetActiveLow.Result">
        <short/>
      </element>
      <element name="TMCP23S17.GetActiveLow.Index">
        <short/>
      </element>
      <element name="TMCP23S17.GetCount">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23S17.GetCount.Result">
        <short/>
      </element>
      <element name="TMCP23S17.GetDirection">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23S17.GetDirection.Result">
        <short/>
      </element>
      <element name="TMCP23S17.GetDirection.Index">
        <short/>
      </element>
      <element name="TMCP23S17.GetInterruptMode">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23S17.GetInterruptMode.Result">
        <short/>
      </element>
      <element name="TMCP23S17.GetInterruptMode.Index">
        <short/>
      </element>
      <element name="TMCP23S17.GetValue">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23S17.GetValue.Result">
        <short/>
      </element>
      <element name="TMCP23S17.GetValue.Index">
        <short/>
      </element>
      <element name="TMCP23S17.SetActiveLow">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23S17.SetActiveLow.Index">
        <short/>
      </element>
      <element name="TMCP23S17.SetActiveLow.AValue">
        <short/>
      </element>
      <element name="TMCP23S17.SetDirection">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23S17.SetDirection.Index">
        <short/>
      </element>
      <element name="TMCP23S17.SetDirection.AValue">
        <short/>
      </element>
      <element name="TMCP23S17.SetInterruptMode">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23S17.SetInterruptMode.Index">
        <short/>
      </element>
      <element name="TMCP23S17.SetInterruptMode.AValue">
        <short/>
      </element>
      <element name="TMCP23S17.SetValue">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23S17.SetValue.Index">
        <short/>
      </element>
      <element name="TMCP23S17.SetValue.aValue">
        <short/>
      </element>
      <element name="TMCP23S17.Create">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23S17.Create.aDevice">
        <short/>
      </element>
      <element name="TMCP23S17.Destroy">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <short>GPIO expanders</short>
      <descr>This unit provides support for GPIO expanders. You will need an GPIO expander if your processor/microcontroller doesn't provide as much GPIO ports as you need.</descr>
    </module><module name="i2c_dev">
      <short>Linux i2c-dev.h</short>
      <descr>This unit is a translation of the i2c-dev.h header file of the Linux Kernel. Use this unit for low level direct access to I2C (Inter Integrated Circuit) or SMBus (System Management Bus) on Linux.</descr>
      <element name="i2c_msg"/>
      <element name="i2c_msg.addr">
        <short>slave address</short>
      </element>
      <element name="i2c_msg.flags"/>
      <element name="i2c_msg.len">
        <short>Message length</short>
      </element>
      <element name="i2c_msg.buf">
        <short>Pointer to message data</short>
      </element>
      <element name="Pi2c_msg"/>
      <element name="I2C_M_TEN"/>
      <element name="I2C_M_RD"/>
      <element name="I2C_M_NOSTART"/>
      <element name="I2C_M_REV_DIR_ADDR"/>
      <element name="I2C_M_IGNORE_NAK"/>
      <element name="I2C_M_NO_RD_ACK"/>
      <element name="I2C_FUNC_I2C"/>
      <element name="I2C_FUNC_10BIT_ADDR"/>
      <element name="I2C_FUNC_PROTOCOL_MANGLING"/>
      <element name="I2C_FUNC_SMBUS_PEC"/>
      <element name="I2C_FUNC_SMBUS_BLOCK_PROC_CALL"/>
      <element name="I2C_FUNC_SMBUS_QUICK"/>
      <element name="I2C_FUNC_SMBUS_READ_BYTE"/>
      <element name="I2C_FUNC_SMBUS_WRITE_BYTE"/>
      <element name="I2C_FUNC_SMBUS_READ_BYTE_DATA"/>
      <element name="I2C_FUNC_SMBUS_WRITE_BYTE_DATA"/>
      <element name="I2C_FUNC_SMBUS_WRITE_WORD_DATA"/>
      <element name="I2C_FUNC_SMBUS_PROC_CALL"/>
      <element name="I2C_FUNC_SMBUS_READ_BLOCK_DATA"/>
      <element name="I2C_FUNC_SMBUS_WRITE_BLOCK_DATA"/>
      <element name="I2C_FUNC_SMBUS_READ_I2C_BLOCK"/>
      <element name="I2C_FUNC_SMBUS_WRITE_I2C_BLOCK"/>
      <element name="I2C_FUNC_SMBUS_BYTE"/>
      <element name="I2C_FUNC_SMBUS_BYTE_DATA"/>
      <element name="I2C_FUNC_SMBUS_WORD_DATA"/>
      <element name="I2C_FUNC_SMBUS_BLOCK_DATA"/>
      <element name="I2C_FUNC_SMBUS_I2C_BLOCK"/>
      <element name="I2C_FUNC_SMBUS_HWPEC_CALC"/>
      <element name="I2C_SMBUS_BLOCK_MAX">
        <short>Maximum block count for SMBus</short>
      </element>
      <element name="I2C_SMBUS_I2C_BLOCK_MAX"/>
      <element name="TI2C_SMBUS_VALUES"/>
      <element name="i2c_smbus_data"/>
      <element name="i2c_smbus_data._byte"/>
      <element name="i2c_smbus_data._word"/>
      <element name="i2c_smbus_data.block"/>
      <element name="Pi2c_smbus_data"/>
      <element name="TI2C_SMBUS_RW_MODE"/>
      <element name="TI2C_SMBUS_RW_MODE.I2C_SMBUS_WRITE">
        <short>Write data to bus</short>
      </element>
      <element name="TI2C_SMBUS_RW_MODE.I2C_SMBUS_READ">
        <short>Read data from bus</short>
      </element>
      <element name="TI2C_SMBUS_TRANSACTION">
        <short>SMBus transaction type</short>
      </element>
      <element name="TI2C_SMBUS_TRANSACTION.I2C_SMBUS_QUICK"/>
      <element name="TI2C_SMBUS_TRANSACTION.I2C_SMBUS_BYTE"/>
      <element name="TI2C_SMBUS_TRANSACTION.I2C_SMBUS_WORD_DATA"/>
      <element name="TI2C_SMBUS_TRANSACTION.I2C_SMBUS_PROC_CALL"/>
      <element name="TI2C_SMBUS_TRANSACTION.I2C_SMBUS_BYTE_DATA"/>
      <element name="TI2C_SMBUS_TRANSACTION.I2C_SMBUS_BLOCK_DATA"/>
      <element name="TI2C_SMBUS_TRANSACTION.I2C_SMBUS_I2C_BLOCK_BROKEN"/>
      <element name="TI2C_SMBUS_TRANSACTION.I2C_SMBUS_BLOCK_PROC_CALL"/>
      <element name="TI2C_SMBUS_TRANSACTION.I2C_SMBUS_I2C_BLOCK_DATA"/>
      <element name="I2C_RETRIES"/>
      <element name="I2C_TIMEOUT"/>
      <element name="I2C_SLAVE"/>
      <element name="I2C_SLAVE_FORCE"/>
      <element name="I2C_TENBIT"/>
      <element name="I2C_FUNCS"/>
      <element name="I2C_RDWR"/>
      <element name="I2C_PEC"/>
      <element name="I2C_SMBUS"/>
      <element name="i2c_smbus_ioctl_data">
        <short>Structure for I2C_SMBUS ioctl call</short>
      </element>
      <element name="i2c_smbus_ioctl_data.read_write">
        <short>Read or write mode</short>
      </element>
      <element name="i2c_smbus_ioctl_data.command"/>
      <element name="i2c_smbus_ioctl_data.size"/>
      <element name="i2c_smbus_ioctl_data.data"/>
      <element name="Pi2c_smbus_ioctl_data"/>
      <element name="i2c_rdwr_ioctl_data">
        <short>Structure for I2C_RDWR ioctl call</short>
      </element>
      <element name="i2c_rdwr_ioctl_data.msgs">
        <short>Pointer to i2c_msgs</short>
      </element>
      <element name="i2c_rdwr_ioctl_data.nmsgs">
        <short>number of i2c_msgs</short>
      </element>
      <element name="Pi2c_rdwr_ioctl_data"/>
      <element name="i2c_smbus_access"/>
      <element name="i2c_smbus_block_process_call"/>
      <element name="i2c_smbus_process_call"/>
      <element name="i2c_smbus_read_block_data"/>
      <element name="i2c_smbus_read_byte"/>
      <element name="i2c_smbus_read_byte_data"/>
      <element name="i2c_smbus_read_i2c_block_data">
        <descr>Until kernel 2.6.22, the length is hardcoded to 32 bytes. If you ask for less than 32 bytes, your code will only work with kernels 2.6.23 and later.</descr>
      </element>
      <element name="i2c_smbus_read_word_data"/>
      <element name="i2c_smbus_write_block_data"/>
      <element name="i2c_smbus_write_byte"/>
      <element name="i2c_smbus_write_byte_data"/>
      <element name="i2c_smbus_write_i2c_block_data"/>
      <element name="i2c_smbus_write_quick"/>
      <element name="i2c_smbus_write_word_data"/>
      <element name="i2c_smbus_access._file">
        <short>File descriptor of I2C/SMBus file</short>
      </element>
      <element name="i2c_smbus_access.read_write"/>
      <element name="i2c_smbus_access.command"/>
      <element name="i2c_smbus_access.size"/>
      <element name="i2c_smbus_access.data"/>
      <element name="i2c_smbus_access.Result"/>
      <element name="i2c_smbus_block_process_call._file"/>
      <element name="i2c_smbus_block_process_call.command"/>
      <element name="i2c_smbus_block_process_call._length"/>
      <element name="i2c_smbus_block_process_call.values"/>
      <element name="i2c_smbus_block_process_call.Result">
        <short>Number of read bytes</short>
      </element>
      <element name="i2c_smbus_process_call._file"/>
      <element name="i2c_smbus_process_call.command"/>
      <element name="i2c_smbus_process_call.value"/>
      <element name="i2c_smbus_process_call.Result"/>
      <element name="i2c_smbus_read_block_data.Result">
        <short>Number of read bytes</short>
      </element>
      <element name="i2c_smbus_read_block_data.values"/>
      <element name="i2c_smbus_read_block_data.command"/>
      <element name="i2c_smbus_read_block_data._file"/>
      <element name="i2c_smbus_read_byte._file"/>
      <element name="i2c_smbus_read_byte.Result"/>
      <element name="i2c_smbus_read_byte_data._file"/>
      <element name="i2c_smbus_read_byte_data.command"/>
      <element name="i2c_smbus_read_byte_data.Result"/>
      <element name="i2c_smbus_read_i2c_block_data._file"/>
      <element name="i2c_smbus_read_i2c_block_data.command"/>
      <element name="i2c_smbus_read_i2c_block_data._length"/>
      <element name="i2c_smbus_read_i2c_block_data.values"/>
      <element name="i2c_smbus_read_i2c_block_data.Result">
        <short>Number of read bytes</short>
      </element>
      <element name="i2c_smbus_read_word_data._file"/>
      <element name="i2c_smbus_read_word_data.command"/>
      <element name="i2c_smbus_read_word_data.Result"/>
      <element name="i2c_smbus_write_block_data._file"/>
      <element name="i2c_smbus_write_block_data.command"/>
      <element name="i2c_smbus_write_block_data._length"/>
      <element name="i2c_smbus_write_block_data.values"/>
      <element name="i2c_smbus_write_block_data.Result"/>
      <element name="i2c_smbus_write_byte._file"/>
      <element name="i2c_smbus_write_byte.value"/>
      <element name="i2c_smbus_write_byte.Result"/>
      <element name="i2c_smbus_write_byte_data._file"/>
      <element name="i2c_smbus_write_byte_data.command"/>
      <element name="i2c_smbus_write_byte_data.value"/>
      <element name="i2c_smbus_write_byte_data.Result"/>
      <element name="i2c_smbus_write_i2c_block_data._file"/>
      <element name="i2c_smbus_write_i2c_block_data.command"/>
      <element name="i2c_smbus_write_i2c_block_data._length"/>
      <element name="i2c_smbus_write_i2c_block_data.values"/>
      <element name="i2c_smbus_write_i2c_block_data.Result"/>
      <element name="i2c_smbus_write_quick._file"/>
      <element name="i2c_smbus_write_quick.value"/>
      <element name="i2c_smbus_write_quick.Result"/>
      <element name="i2c_smbus_write_word_data._file"/>
      <element name="i2c_smbus_write_word_data.command"/>
      <element name="i2c_smbus_write_word_data.value"/>
      <element name="i2c_smbus_write_word_data.Result"/>
    </module><module name="mcp23017">
      <element name="sInvalidAddress">
        <seealso>
          <link id="EInvalidMCP23X17Address"/>
        </seealso>
      </element>
      <element name="MCP23X17_DEFAULT_ADDRESS">
        <short>Default address of MCP23017</short>
        <descr>This is the default address of a bunch of GPIO extenders like the MCP23017, MCP23S17, MCP23018 and MCP23S18. You have to bias the chip's address by connecting the address pin(s) to GND or VCC. See your chip's datasheet for more information.</descr>
      </element>
      <element name="EInvalidMCP23X17Address">
        <short>Invalid chip address</short>
        <seealso>
          <link id="sInvalidAddress"/>
        </seealso>
      </element>
      <element name="TMCP23X17Controller">
        <short>Abstract base controller for MCP23017 and MCP23S17</short>
        <descr>Provides an abstract interface for accessing MCP23017 and MCP23S17 following their internal registers.

Use this class only if you need direct access to the internal registers. Otherwise use <link id="gpioexp.TMCP23017">TMCP23017</link> or <link id="gpioexp.TMCP23S17">TMCP23S17</link> from unit <link id="gpioexp"/>.</descr>
        <seealso>
          <link id="TMCP23017Controller"/>
          <link id="TMCP23S17Controller"/>
        </seealso>
      </element>
      <element name="TMCP23X17Controller.fIOCON">
        <short>Internal IOCON buffer</short>
        <descr>This field holds a internal backup of 
<link id="TMCP23X17Controller.IOCON">Input/Output configuration register</link>. It is used for easy access of the single bit properties.</descr>
        <seealso>
          <link id="TMCP23X17Controller.IOCON"/>
        </seealso>
      </element>
      <element name="TMCP23X17Controller.fOwnsDevice">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TMCP23X17Controller.GetAddress">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23X17Controller.GetAddress.Result">
        <short/>
      </element>
      <element name="TMCP23X17Controller.SetIOCONValue">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23X17Controller.SetIOCONValue.AIndex">
        <short/>
      </element>
      <element name="TMCP23X17Controller.SetIOCONValue.AValue">
        <short/>
      </element>
      <element name="TMCP23X17Controller.GetIOCONValue">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23X17Controller.GetIOCONValue.Result">
        <short/>
      </element>
      <element name="TMCP23X17Controller.GetIOCONValue.AIndex">
        <short/>
      </element>
      <element name="TMCP23X17Controller.GetDEFVAL">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23X17Controller.GetDEFVAL.Result">
        <short/>
      </element>
      <element name="TMCP23X17Controller.GetDEFVAL.AIndex">
        <short/>
      </element>
      <element name="TMCP23X17Controller.GetGPINTEN">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23X17Controller.GetGPINTEN.Result">
        <short/>
      </element>
      <element name="TMCP23X17Controller.GetGPINTEN.AIndex">
        <short/>
      </element>
      <element name="TMCP23X17Controller.GetGPIO">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23X17Controller.GetGPIO.Result">
        <short/>
      </element>
      <element name="TMCP23X17Controller.GetGPIO.AIndex">
        <short/>
      </element>
      <element name="TMCP23X17Controller.GetGPPU">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23X17Controller.GetGPPU.Result">
        <short/>
      </element>
      <element name="TMCP23X17Controller.GetGPPU.AIndex">
        <short/>
      </element>
      <element name="TMCP23X17Controller.GetINTCAP">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23X17Controller.GetINTCAP.Result">
        <short/>
      </element>
      <element name="TMCP23X17Controller.GetINTCAP.AIndex">
        <short/>
      </element>
      <element name="TMCP23X17Controller.GetINTCON">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23X17Controller.GetINTCON.Result">
        <short/>
      </element>
      <element name="TMCP23X17Controller.GetINTCON.AIndex">
        <short/>
      </element>
      <element name="TMCP23X17Controller.GetINTF">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23X17Controller.GetINTF.Result">
        <short/>
      </element>
      <element name="TMCP23X17Controller.GetINTF.AIndex">
        <short/>
      </element>
      <element name="TMCP23X17Controller.GetIOCON">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23X17Controller.GetIOCON.Result">
        <short/>
      </element>
      <element name="TMCP23X17Controller.GetIOCON.AIndex">
        <short/>
      </element>
      <element name="TMCP23X17Controller.GetIODIR">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23X17Controller.GetIODIR.Result">
        <short/>
      </element>
      <element name="TMCP23X17Controller.GetIODIR.AIndex">
        <short/>
      </element>
      <element name="TMCP23X17Controller.GetIPOL">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23X17Controller.GetIPOL.Result">
        <short/>
      </element>
      <element name="TMCP23X17Controller.GetIPOL.AIndex">
        <short/>
      </element>
      <element name="TMCP23X17Controller.GetOLAT">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23X17Controller.GetOLAT.Result">
        <short/>
      </element>
      <element name="TMCP23X17Controller.GetOLAT.AIndex">
        <short/>
      </element>
      <element name="TMCP23X17Controller.SetDEFVAL">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23X17Controller.SetDEFVAL.AIndex">
        <short/>
      </element>
      <element name="TMCP23X17Controller.SetDEFVAL.AValue">
        <short/>
      </element>
      <element name="TMCP23X17Controller.SetGPINTEN">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23X17Controller.SetGPINTEN.AIndex">
        <short/>
      </element>
      <element name="TMCP23X17Controller.SetGPINTEN.AValue">
        <short/>
      </element>
      <element name="TMCP23X17Controller.SetGPIO">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23X17Controller.SetGPIO.AIndex">
        <short/>
      </element>
      <element name="TMCP23X17Controller.SetGPIO.AValue">
        <short/>
      </element>
      <element name="TMCP23X17Controller.SetGPPU">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23X17Controller.SetGPPU.AIndex">
        <short/>
      </element>
      <element name="TMCP23X17Controller.SetGPPU.AValue">
        <short/>
      </element>
      <element name="TMCP23X17Controller.SetINTCON">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23X17Controller.SetINTCON.AIndex">
        <short/>
      </element>
      <element name="TMCP23X17Controller.SetINTCON.AValue">
        <short/>
      </element>
      <element name="TMCP23X17Controller.SetIOCON">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23X17Controller.SetIOCON.AIndex">
        <short/>
      </element>
      <element name="TMCP23X17Controller.SetIOCON.AValue">
        <short/>
      </element>
      <element name="TMCP23X17Controller.SetIODIR">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23X17Controller.SetIODIR.AIndex">
        <short/>
      </element>
      <element name="TMCP23X17Controller.SetIODIR.AValue">
        <short/>
      </element>
      <element name="TMCP23X17Controller.SetIPOL">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23X17Controller.SetIPOL.AIndex">
        <short/>
      </element>
      <element name="TMCP23X17Controller.SetIPOL.AValue">
        <short/>
      </element>
      <element name="TMCP23X17Controller.SetOLAT">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23X17Controller.SetOLAT.AIndex">
        <short/>
      </element>
      <element name="TMCP23X17Controller.SetOLAT.AValue">
        <short/>
      </element>
      <element name="TMCP23X17Controller.GetRegisterValue">
        <short>Abstract value retrival method</short>
      </element>
      <element name="TMCP23X17Controller.GetRegisterValue.Result">
        <short>Register value</short>
      </element>
      <element name="TMCP23X17Controller.GetRegisterValue.aRegister">
        <short>Register address</short>
        <errors>Invalid register address may result in garbage result or application failure.</errors>
      </element>
      <element name="TMCP23X17Controller.SetRegisterValue">
        <short>Abstract register value setter</short>
      </element>
      <element name="TMCP23X17Controller.SetRegisterValue.aRegister">
        <short>Register address</short>
        <descr>Value is not validated.</descr>
        <errors>Invalid register address may result in unexpected behaviour.</errors>
      </element>
      <element name="TMCP23X17Controller.SetRegisterValue.aValue">
        <short>New register value</short>
      </element>
      <element name="TMCP23X17Controller.Create">
        <short>New instance</short>
        <descr>This constructor should be overwritten in subclass.</descr>
      </element>
      <element name="TMCP23X17Controller.IODIRA">
        <short>Input/Output Direction - Port A</short>
        <descr>
          <table>
            <tr>
              <td>Value</td>
              <td>Description</td>
            </tr>
            <tr>
              <td>0</td>
              <td>output</td>
            </tr>
            <tr>
              <td>1 (default)</td>
              <td>input</td>
            </tr>
          </table>
        </descr>
      </element>
      <element name="TMCP23X17Controller.IPOLA">
        <short>Input Polarity - Port A</short>
        <descr>Input polarity 1 = reverted value, 0 = real value (default)</descr>
      </element>
      <element name="TMCP23X17Controller.GPINTENA">
        <short>Interrupt Enable - Port A</short>
      </element>
      <element name="TMCP23X17Controller.DEFVALA">
        <short>Default Value for interrupt condition - Port A</short>
        <seealso>
          <link id="TMCP23X17Controller.DEFVALB"/>
        </seealso>
      </element>
      <element name="TMCP23X17Controller.INTCONA">
        <short>Interrupt Condition - Port A</short>
      </element>
      <element name="TMCP23X17Controller.IOCONA">
        <short>Input/Output Configuration</short>
        <descr>Register IOCON is shared between both GPIO ports.

See IOCON for details.</descr>
        <seealso>
          <link id="TMCP23X17Controller.IOCON"/>
        </seealso>
      </element>
      <element name="TMCP23X17Controller.GPPUA">
        <short>Pull Up resitors - Port A</short>
      </element>
      <element name="TMCP23X17Controller.INTFA">
        <short>Interrupt Flag - Port A</short>
        <descr>Shows which GPIO port caused the interrupt.</descr>
      </element>
      <element name="TMCP23X17Controller.INTCAPA">
        <short>Interrupt Capture - Port A</short>
      </element>
      <element name="TMCP23X17Controller.GPIOA">
        <short>GPIO values - Port A</short>
        <descr>Shows the current status of GPIO pins.

Write updates <link id="TMCP23X17Controller.OLATA">Output Latches register</link>.</descr>
        <seealso>
          <link id="TMCP23X17Controller.OLATA"/>
        </seealso>
      </element>
      <element name="TMCP23X17Controller.OLATA">
        <short>Output Latches - Port A</short>
        <seealso>
          <link id="TMCP23X17Controller.GPIOA"/>
        </seealso>
      </element>
      <element name="TMCP23X17Controller.IODIRB">
        <short>Input/Output Direction - Port B</short>
        <descr>
          <table>
            <tr>
              <td>Value</td>
              <td>Description</td>
            </tr>
            <tr>
              <td>0</td>
              <td>output</td>
            </tr>
            <tr>
              <td>1 (default)</td>
              <td>input</td>
            </tr>
          </table>
        </descr>
      </element>
      <element name="TMCP23X17Controller.IPOLB">
        <short>Input Polarity - Port B</short>
        <descr>Input polarity 1 = reverted value, 0 = real value (default)</descr>
      </element>
      <element name="TMCP23X17Controller.GPINTENB">
        <short>Interrupt Enable - Port A</short>
      </element>
      <element name="TMCP23X17Controller.DEFVALB">
        <short>Default Value for interrupt condition - Port B</short>
        <seealso>
          <link id="TMCP23X17Controller.DEFVALA"/>
        </seealso>
      </element>
      <element name="TMCP23X17Controller.INTCONB">
        <short>Interrupt Condition - Port A</short>
      </element>
      <element name="TMCP23X17Controller.IOCONB">
        <short>Input/Output Configuration</short>
        <descr>Register IOCON is shared between both GPIO ports.

See IOCON for details.</descr>
        <seealso>
          <link id="TMCP23X17Controller.IOCON"/>
        </seealso>
      </element>
      <element name="TMCP23X17Controller.GPPUB">
        <short>Pull Up resitors - Port B</short>
      </element>
      <element name="TMCP23X17Controller.INTFB">
        <short>Interrupt Flag - Port B</short>
        <descr>Shows which GPIO port caused the interrupt.</descr>
      </element>
      <element name="TMCP23X17Controller.INTCAPB">
        <short>Interrupt Capture - Port B</short>
      </element>
      <element name="TMCP23X17Controller.GPIOB">
        <short>GPIO values - Port B</short>
        <descr>Shows the current status of GPIO pins.

Write updates <link id="TMCP23X17Controller.OLATB">Output Latches register</link>.</descr>
        <seealso>
          <link id="TMCP23X17Controller.OLATB"/>
        </seealso>
      </element>
      <element name="TMCP23X17Controller.OLATB">
        <short>Output Latches - Port B</short>
        <seealso>
          <link id="TMCP23X17Controller.GPIOB"/>
        </seealso>
      </element>
      <element name="TMCP23X17Controller.IOCON">
        <short>Input/Output Configuration</short>
        <descr>Configuration register for both GPIO ports.

This property allows access to the whole register. Each configuration bit has also it's own property. Please refer to the chip's datasheet or each individual property for more information.</descr>
        <seealso>
          <link id="TMCP23X17Controller.INTPOL"/>
          <link id="TMCP23X17Controller.ODR"/>
          <link id="TMCP23X17Controller.SEQOP"/>
          <link id="TMCP23X17Controller.MIRROR"/>
          <link id="TMCP23X17Controller.HAEN"/>
          <link id="TMCP23X17Controller.DISSLW"/>
          <link id="TMCP23X17Controller.BANK"/>
        </seealso>
      </element>
      <element name="TMCP23X17Controller.BANK">
        <short>BANK mode</short>
        <descr>BANK biases the register's addresses. This class can handle both addressing methods.</descr>
      </element>
      <element name="TMCP23X17Controller.MIRROR">
        <short>Mirror Interrupt</short>
        <descr>0 = seperate interrupts (default),
 1 = interrrupts are shared between ports and interrupt pins</descr>
        <seealso>
          <link id="TMCP23X17Controller.IOCON"/>
        </seealso>
      </element>
      <element name="TMCP23X17Controller.SEQOP">
        <short>Sequential Operation</short>
        <descr>If set, internal register pointer is updated after each operation.</descr>
        <seealso>
          <link id="TMCP23X17Controller.IOCON"/>
        </seealso>
      </element>
      <element name="TMCP23X17Controller.DISSLW">
        <short>Slew Rate</short>
        <seealso>
          <link id="TMCP23X17Controller.IOCON"/>
        </seealso>
      </element>
      <element name="TMCP23X17Controller.HAEN">
        <short>Hardware Address Enable</short>
        <descr>Only used in <link id="TMCP23S17Controller">MCP23S17</link>.

If set, the address pins bias the chip's address. Default <var>False</var>.</descr>
      </element>
      <element name="TMCP23X17Controller.ODR">
        <short>Open Drain for interrupt pins</short>
        <descr>0 = INTPOL used,
1 = open-drain output (overrides INTPOL)</descr>
        <seealso>
          <link id="TMCP23X17Controller.IOCON"/>
          <link id="TMCP23X17Controller.INTPOL"/>
        </seealso>
      </element>
      <element name="TMCP23X17Controller.INTPOL">
        <short>Interrupt Polarity</short>
        <descr>
          <p>Is overridden by 
<link id="TMCP23X17Controller.ODR">Open Drain flag</link>.</p>
          <table>
            <tr>
              <td>Value</td>
              <td>Description</td>
            </tr>
            <tr>
              <td>0 (default)</td>
              <td>active-low</td>
            </tr>
            <tr>
              <td>1</td>
              <td>active-high</td>
            </tr>
          </table>
        </descr>
        <seealso>
          <link id="TMCP23X17Controller.IOCON"/>
          <link id="TMCP23X17Controller.ODR"/>
        </seealso>
      </element>
      <element name="TMCP23X17Controller.Address">
        <short>Chip address</short>
        <descr>MCP23017 and MCP23S17 have 3 address pins, MCP23018 and MCP23S18 have 1 address pin biasing the last three bits of the chip's internal address.

The SPI devices don't use addresses; this must be enabled in the IOCON register.</descr>
        <seealso>
          <link id="TMCP23X17Controller.HAEN"/>
          <link id="TMCP23X17Controller.IOCON"/>
        </seealso>
      </element>
      <element name="TMCP23X17Controller.OwnsDevice">
        <short>Free Device on destruction</short>
        <descr>If set, the assigned device will be freed at destruction.

This has to be implented in a subclass destructor.</descr>
      </element>
      <element name="TMCP23017Controller">
        <short>Accessing MCP23017 using I2C device</short>
      </element>
      <element name="TMCP23017Controller.fI2CDevice">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TMCP23017Controller.GetRegisterValue">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23017Controller.GetRegisterValue.Result">
        <short/>
      </element>
      <element name="TMCP23017Controller.GetRegisterValue.aRegister">
        <short/>
      </element>
      <element name="TMCP23017Controller.SetRegisterValue">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23017Controller.SetRegisterValue.aRegister">
        <short/>
      </element>
      <element name="TMCP23017Controller.SetRegisterValue.aValue">
        <short/>
      </element>
      <element name="TMCP23017Controller.Create">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23017Controller.Create.aI2CDevice">
        <short/>
      </element>
      <element name="TMCP23017Controller.Create.aOwnsDevice">
        <short/>
      </element>
      <element name="TMCP23017Controller.Destroy">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23017Controller.I2CDevice">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TMCP23S17Controller">
        <short>Accessing MCP23S17 using SPI device</short>
      </element>
      <element name="TMCP23S17Controller.fSPIDevice">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TMCP23S17Controller.GetRegisterValue">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23S17Controller.GetRegisterValue.Result">
        <short/>
      </element>
      <element name="TMCP23S17Controller.GetRegisterValue.aRegister">
        <short/>
      </element>
      <element name="TMCP23S17Controller.SetRegisterValue">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23S17Controller.SetRegisterValue.aRegister">
        <short/>
      </element>
      <element name="TMCP23S17Controller.SetRegisterValue.aValue">
        <short/>
      </element>
      <element name="TMCP23S17Controller.Create">
        <short>Create new instance</short>
      </element>
      <element name="TMCP23S17Controller.Create.aSPIDevice">
        <short>SPI device</short>
        <seealso>
          <link id="TMCP23S17Controller.SPIDevice"/>
        </seealso>
      </element>
      <element name="TMCP23S17Controller.Create.aOwnsDevice">
        <short>Free device on destruction</short>
        <seealso>
          <link id="TMCP23X17Controller.OwnsDevice"/>
        </seealso>
      </element>
      <element name="TMCP23S17Controller.Destroy">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TMCP23S17Controller.SPIDevice">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <short>Plain MCP23017 and MCP23S17 access</short>
      <descr>This unit provides classes for plain access of MCP23017 and MCP23S17 (and compatible chips).</descr>
      <seealso>
        <link id="TMCP23X17Controller"/>
        <link id="TMCP23017Controller"/>
        <link id="TMCP23S17Controller"/>
      </seealso>
    </module><module name="spidev">
      <short>Translation of spidev.h</short>
      <descr>This is a translation of the spidev.h header file of the Linux kernel. Unfortunatly the Free Pascal Compiler doesn't ship with a portable translation of some basic C macros which are essantial for the IoCtl system call. These macros and constans may move to another unit.</descr>
      <!-- constant Visibility: default -->
      <element name="SPI_CPHA">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="SPI_CPOL">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="SPI_MODE_0">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="SPI_MODE_1">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="SPI_MODE_2">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="SPI_MODE_3">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="SPI_CS_HIGH">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="SPI_LSB_FIRST">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="SPI_3WIRE">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="SPI_LOOP">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="SPI_NO_CS">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="SPI_READY">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="SPI_IOC_MAGIC">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- record type Visibility: default -->
      <element name="spi_ioc_transfer">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="spi_ioc_transfer.len">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="spi_ioc_transfer.speed_hz">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="spi_ioc_transfer.delay_usecs">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="spi_ioc_transfer.bits_per_word">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="spi_ioc_transfer.cs_change">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="spi_ioc_transfer.pad">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="_IOC_NRBITS">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="_IOC_TYPEBITS">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="_IOC_SIZEBITS">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="_IOC_DIRBITS">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="_IOC_NONE">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="_IOC_WRITE">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="_IOC_READ">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="_IOC_NRMASK">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="_IOC_TYPEMASK">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="_IOC_SIZEMASK">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="_IOC_DIRMASK">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="_IOC_NRSHIFT">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="_IOC_TYPESHIFT">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="_IOC_SIZESHIFT">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="_IOC_DIRSHIFT">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- function Visibility: default -->
      <element name="_IOC">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="_IOC.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="_IOC.dir">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="_IOC._type">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="_IOC.nr">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="_IOC.size">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="_IOR">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="_IOR.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="_IOR._type">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="_IOR.nr">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="_IOR.size">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="_IOW">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="_IOW.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="_IOW._type">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="_IOW.nr">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="_IOW.size">
        <short/>
      </element>
      <!-- constant Visibility: default -->
      <element name="SPI_IOC_RD_MODE">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="SPI_IOC_WR_MODE">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="SPI_IOC_RD_LSB_FIRST">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="SPI_IOC_WR_LSB_FIRST">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="SPI_IOC_RD_BITS_PER_WORD">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="SPI_IOC_WR_BITS_PER_WORD">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="SPI_IOC_RD_MAX_SPEED_HZ">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="SPI_IOC_WR_MAX_SPEED_HZ">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- function Visibility: default -->
      <element name="SPI_MSGSIZE">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="SPI_MSGSIZE.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="SPI_MSGSIZE.n">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="SPI_IOC_MESSAGE">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="SPI_IOC_MESSAGE.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="SPI_IOC_MESSAGE.N">
        <short/>
      </element>
    </module>
  </package>
</fpdoc-descriptions>
